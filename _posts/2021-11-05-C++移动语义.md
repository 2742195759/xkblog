---
layout : post
title  : CIKM展示PPT笔记
date   : 2021-09-26 13:00:00 +0000
category : scholar
typora-copy-images-to: ../../../code/xkblog/public/img/
typora-root-url: ../../../code
---

## 主要脉络

#### 主要动机

**定义：对象控制权：** 在设计C++系统中，如果是堆内存，那么内存分配和内存回收是两个必须要做的步骤。谁负责回收，谁就负责独占这个对象。比如一个对象Context负责创建Widget，并且Context负责管理Widget，即在不需要的时候回收Widget，那么Context对象就独占了Widget对象。其他地方的对Widget的使用只是一个简单的引用或者是指针，用完不需要delete。所以其他对象只是共享使用权。

移动语义主要动机来源于对独占对象的转移。比如你希望将Widget转移到另外一个新的NewContext对象中，原来的NewContext对象不负责管理Widget的生命周期，那么你有两个方案：

1. NewContext对象拷贝一份Widget，然后删除吊原来的Context。（析构Context时，因为Context拥有Widget控制权，所以会delete掉原来的Widget，没有内存泄露。（拷贝语义）
2. 直接讲Widget的指针转移过来，NewContext负责管理Widget，原来的Context析构的时候不再delete Widget。（移动语义）

对于上述的两个方案，肯定是移动语义开销更小。这就是移动语义的动机，希望引入移动语义来实现浅拷贝的同时，停止原来对象对成员对象的控制权。

注意上面拷贝语义是const的，即不会改变被拷贝对象；但是移动语义是非const，他会剥去原有对象的控制权，会修改被移动对象。

对于一些编译期生成的临时对象，因为这些临时对象马上就将析构，所以直接剥夺即可。所以移动语义天然适合移动临时对象。即右值。(对临时对象的转移语义其实也是编译期的主要要目的，所以会发现很多规定都是对临时对象的。但是其实用起来是很灵活的，因此有move的函数的存在使他们更加灵活。)

#### 左值，右值，左值引用，右值引用

为了引入移动语义，必须引入左值和右值。否则编译期不知道你想要拷贝还是移动。所以为了使用函数重载区分，引入了新的`右值引用`的概念。写法 ```Widget&&``` 。右值引用告诉编译期，这个变量适合移动。

右值引用只能绑定到一个右值上。（为了告诉编译期这个是一个右值，即你希望移动）。注意这是绑定，即初始化过程只能用右值或者右值引用初始化。

其实本质上来说你想怎么弄都可以，比如你可以通过 `右值引用 = std::move(左值引用)` 的方式获取一个左值的右值引用。所以只有在初始化的时候才需要考虑这些绑定规则。得到引用之后可以随意转换，转换的过程就是告诉编译期你是否希望移动他们，这里开始就是你随心所欲了，只需要记住转移的话，原来对象的某些控制权会被新对象独享。

